# The Pragmatic Programmer By Andrew Hunt and David Thomas

Check out the tips cut out from the book.

What makes a pragmatic programmer? Think about what you're doing while you’re doing it.

We who cut mere stones must always be envisioning cathedrals.

Within the overall structure of a project there is always room for individuality and craftsmanship.

“Kaizen” is a Japanese term that captures the concept of continuously making many small improvements.

Every day work to refine your skills and add new tools to your repertoire.

## Chapter 1 - A Pragmatic Philosophy

Pragmatic programmers think beyond the immediate problem, placing it in its larger context and seeking out the bigger picture.

### Topic 1 - It’s your life m

“I’m not in this world to live up to your expectations and you’re not in this world to live up to mine.” - Bruce Lee

The industry gives you a remarkable set of opportunities. Be proactive, and take them.

### Topic 2 - The cat ate my source code

One of the cornerstones of pragmatic philosophy is the idea of taking responsibility for yourself and your actions in terms of your career advancement, your learning and education, your project, and your day-to-day work.

We can be proud of our abilities, but we must own up to our shortcomings - our ignorance and our mistakes.

#### Team Trust

Trust in a team is absolutely essential for creativity and collaboration according to the research literature.

#### Take Responsibility

It is up to you to provide solutions, not excuses.

Before you approach anyone to tell them why something can’t be done, is late or is broken, stop and listen to yourself.

Run through the conversation in your mind.

Don’t be afraid to ask, or to admit that you need help.

Try to flush out the lame excuses before voicing them aloud.

### Topic 3 - Software entropy

The laws of thermodynamics guarantee that the entropy in the universe tends toward a maximum.

There are many factors that can contribute to software rot. The most important one seems to be the psychology, or culture, at work on a project.

A common trigger mechanism is the infamous first broken window. Once the first broken window is left unfixed, more and more stuff will break down.

Hopelessness can be contagious.

Don’t leave “broken windows” (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered.

Perhaps you can comment out the offending code, or display a “Not Implemented” message, or substitute dummy data instead. Take some action to prevent further damage and to show that you’re on top of the situation.

#### First, Do No Harm

Don’t cause collateral damage just because there’s a crisis of some sort. One broken window is one too many.

What is a broken window? A badly designed piece of code, a poor management decision that the team must learn to live with for the duration of the project.

Challenge:

- Choose two or three broken windows and discuss with your colleagues what the problems are and what could be done to fix them

### Topic 4 - Stone soup and boiled frogs

Act as a catalyst, bringing the village together so they can jointly produce something that they couldn’t have done by themselves - a synergistic result. Eventually everyone wins.

Everyone will guard their own resources. SOmetimes this is called “start-up fatigue”.

Work out what you can reasonably ask for. Develop it well. Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added…” Pretend it’s not important.

People find it easier to join an ongoing success. Show them a glimpse of the future and you’ll get them to rally around.

“It’s easier to ask forgiveness than it is to get permission.” - Rear Admiral Dr. Grace Hopper

#### The Villager’s Side

Things just creep up on us. Keep an eye on the big picture. COnstantly review what’s happening around you, not just what you personally are doing.

Challenge:

- Situational awareness - a technique practiced by folks ranging from Boy and Girl Scouts to Navy SEALs
  - Get in the habit of really looking and noticing your surroundings
  - Then do the same for your project

### Topic 5 - Good-enough software

“Good enough” does not imply sloppy or poorly produced code. All systems must meet their users’ requirements to be successful, and meet basic performance, privacy and security standards.

We are simply advocating that users be given an opportunity to participate in the process of deciding when what you’ve produced is good enough for their needs.

Often you’ll be in situations where trade-offs are involved. If you give your users something to play with early, their feedback will often lead you to a better eventual solution.

#### Know When To Stop

Don’t spoil a perfectly good program by over-embellishment and over refinement. It may not be perfect, but don’t worry. It will never be perfect.

Challenge:

- Feature bloat? Software is containing far more features than you would ever use, each feature introducing more opportunity for bugs and security vulnerabilities, and making the features you do use harder to find and manage

### Topic 6 - Your knowledge portfolio

“An investment in knowledge always pays the best interest” - Benjamin Franklin

Your knowledge and experience are your most important day-to-day professional assets. Unfortunately, they’re expiring assets, value diminishes over time. Your knowledge becomes out of date as new techniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant.

Your ability to learn new things is your most important strategic asset.

#### Your Knowledge Portfolio

All the facts programmers know about computing, the app domains they work in, and all their experience as their knowledge portfolio. Managing a knowledge portfolio is similar to managing an investment portfolio:

1. Serious investors invest regularly - as a habit
2. Diversification is the key to long-term success
3. Smart investors balance their portfolios between conservative and high-risk, high-reward investments
4. Investors try to buy low and sell high for maximum return
5. Portfolios should be reviewed and rebalanced periodically

#### Building Your Portfolio

- Invest regularly
  - The habit is as important as the sums, so plan to use a consistent time and place, away from interruptions
- Diversify
  - The more different things you know, the more valuable you are
- Manage risk
  - Don’t put all your technical eggs in one basket 
- Review and re-balance

#### Goals

- Learn at least one new language every year
  - Diff languages solve the same problems in different ways
  - Broaden your thinking
- Read a technical book each month
  - Browse the booksellers for technical books on interesting topics related to your current project
- Read nontechnical books, too
  - Computers are used by people
  - Don’t forget the human side of the equation
- Take classes
- Participate in local user groups and meetups
  - Find out what ppl are working on outside your company, actively participate
- Experiment with diff environments
- Stay current
  - Read news and posts online on technology

Cross-pollination of ideas is important.

#### Opportunities For Learning

All of this reading and researching takes time, and time is already in short supply. So you need to plan ahead. Always have something to read in an otherwise dead moment.

#### Critical Thinking

Ensure that the knowledge in your portfolio is accurate and unswayed by either vendor or media type. Never underestimate the power of commercialism.

Critical thinking is an entire discipline unto itself, and we encourage you to read and study all you can about it:

- Ask the “5 whys”
  - Ask “why?” at least five times
- Who does this benefit?
  - Follow the money
- What’s the context?
  - “One size fits all” solutions don’t work
- When or where could this work?
  - Don’t stop with the first-order thinking, but always use second-order thinking
- Why is this a problem?

Challenges:

- Start learning a new language this week
- Start reading a new book
- Get out and talk technology with ppl who aren’t involved in your current project

### Topic 7 - Communicate

It’s not just what you’ve got, but also how you package it. A good idea is an orphan without effective communication.

A large part of our day is spent communicating, so we need to do it well.

Treat English as another programming language: honor the DRY principle, ETC, automation and so on.

#### Know Your Audience

You’re communicating only if you’re conveying what you mean to convey - just talking isn’t enough.

Understand the needs, interests, and capabilities of your audience.

By making the appropriate pitch to each group, you’ll get them all excited about your project.

Gather feedback. Don’t just wait for questions: ask for them. Look at body language, and facial expressions. “The meaning of your communication is the response you get”. Continuously improve your knowledge of your audience as you communicate.

#### Know What You Want To Say

Plan what you want to say. Write an outline. Then ask yourself, “does this communicate what I want to express to my audience in a way that works for them?” Refine it until it does.

When going to a meeting, jot down the ideas you want to communicate, and plan a couple of strategies for getting them across.

#### Choose Your Moment

Make what you’re saying relevant in time, as well as in content.

#### Choose A Style

Adjust the style of your delivery to suit your audience.

#### Make It Look Good

Your ideas need to be a good looking vehicle to convey them to your audience.

#### Involve Your Audience

Get feedback on early drafts of your document.

#### Be A Listener

Listen to your audience. If you don’t listen to them, they won’t listen to you.

#### Get Back To People

Always respond to emails and voicemails, even if they response is simply, “I’ll get back to you later”.

The more effective communication, the more influential you become.

#### Documentation

Embrace documentation as an integral part of the overall dev process. Keeping documentation close at hand in the code itself is easier to maintain and access. It is recommended adding comments to modules and exported functions.

Restrict your API commenting to discussing why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant - and is a violation of the DRY principle.

Commenting source code gives you the perfect opportunity to document those elusive bits, engineering trade-offs, why decisions are made, what other alternatives were discarded, and so on.

Challenge:

- Talk to your audience afterward and see how accurate your assessment of their needs was

## Chapter 2 - A Pragmatic Approach

The essence of good design. Everything follows from this.

You can survive these scarcities better if you get good at working out how long things will take, AKA estimating.

### Topic 8 - The essence of good design

A thing is well-designed if it adapts to the people who use it. For code that means it must adapt by changing. Follow the ETC principle, Easier To Change.

Why is decoupling good? Bc by isolating concerns we make each easier to change. ETC.

Why is the single responsibility principle useful? Because a change in requirements is mirrored by a change in just one module. ETC.

#### ETC Is A Value, Not A Rule

ETC is a guide, floating just behind your conscious thought, subtle nudging you in the right direction.

“Did the thing I just did make the overall system easier or harder to change?” Great question to fall into the ETC habit.

Make what you write replaceable. Thinking about keeping code decoupled and cohesive.

Treat this as a way to develop instincts.

Challenge:

- What can you do to eliminate the negatives and accentuate the positives?

### Topic 9 - DRY - the evils of duplication

As programmers, we collect, organize, maintain and harness knowledge, but knowledge isn’t stable. It changes often, and rapidly. Instability means that we spend a large part of our time in maintenance mode, reorganizing and re-expressing the knowledge in our systems. Programmers are in constant maintenance mode.

DRY helps develop software reliably. Every piece of knowledge must have a single, unambiguous, authoritative representation within a system. DRY - Don’t Repeat Yourself!

Dry is about the duplication of knowledge, of intent.There is duplication in code, but not all code duplication is knowledge duplication. Coincidences are not duplications.

There is duplication in documentation. Comments in code help as documentation, but do not reiterate what you wrote, instead write why it was written that way.

There are DRY violations in data. It’s better to make a field calculated in a data or interface. The trick is to localize the impact. All services offered by a moduled should be available through a uniform notation.

#### Representational Duplication

Your code interfaces to the outside world. The duplication here is that two things (your code and the external entity) have to have knowledge of the representation of their interface.

Strategies to mitigate duplication:

- Duplication across internal APIs: store your APIs in a central repo, to be shared across teams
- Duplication across external APIs: i.e. OpenAPI, helps to integrate more reliably with the service
- Duplication with data sources

#### Inter-developer Duplication

Encourage active and frequent communication between developers.

Appoint a team member as the project librarian, whose job is to facilitate the exchange of knowledge. Have a central place in the source tree where utility routines and scripts can be stored. Make a point of reading other people’s source code and documentation.

Make it easy to reuse! Foster an environment where it’s easier to find and reuse existing stuff than to write it yourself. If you fail to reuse, you risk duplicating knowledge.

### Topic 10 Orthogonality

“Orthogonality” is a term from geography, two lines are orthogonal if they meet at right angles, such as the axes on a graph. In computing, it signifies a kind of independence or decoupling. Two or more things are orthogonal if changes in one do not affect any of the others.

#### Benefits of Orthogonality

Eliminate effects between unrelated things. Design components that are self-contained: independent and with a single, well-defined purpose, cohesion.

#### Gain Productivity

- Changes are localized, so development time and testing time are reduced
- Promotes reuse, the more loosely coupled your systems, the easier they are to reconfigure and re-engineer
- You get more functionality per unit effort by combining orthogonal components

#### Reduce Risk

- Diseased sections of code are isolated
- Less fragile
- Be better tested
- Not as tightly tied to a particular external entity

#### Design

Orthogonality AKA modular, component-based, and layered. Systems should be composed of a set of cooperating modules, each of which implements functionality independent of the others.

These components are organized into layers, each providing a level of abstraction. This layered approach is a powerful way to design orthogonal systems. Each layer uses only the abstractions provided by the layers below it, so there is great flexibility in implementing changes.

Layering reduces the risk of runaway dependencies between modules. If I dramatically change the requirements behind a particular function, how many modules are affected? In an orthogonal system, the answer should be “one”.

Don’t rely on the properties of the things you can’t control.

#### Toolkits and Libraries

Be careful to preserve the orthogonality of your system as you introduce third-party toolkits and libraries. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.

#### Coding

Monitor not just what you are doing but also the larger context of the application, you might unintentionally duplicate functionally in some other module, or express existing knowledge twice.

- Keep your code decoupled
  - Write shy code - modules that don’t reveal anything unnecessary to other modules and that don’t rely on other modules’ implementations
  - If you need to change an object’s state, get the object to do it for you
- Avoid global data
  - It ties itself into the other components that share the data
  - Your code is easier to understand and maintain if you explicitly pass any required context into your modules
  - Singleton pattern is a way of ensuring that there is only one instance of an object of a particular class
  - They can also lead to unnecessary linkage
- Avoid similar functions
  - Duplicate code is a symptom of structural problems

Get into the habit of being constantly critical of your code. Reorganize it to improve its structure and orthogonality, AKA refactor it.

#### Testing

Orthogonally designed systems are easier to test. Module level (or unit) testing is considerably easier to specify and perform than integration testing. Automatic tests are encouraged, as part of the regular build process.

Writing unit tests is itself an interesting test of orthogonality.

Bug fixing is also a good time to assess the orthogonality of the system.

#### Documentation

The axes are content and presentation.

#### Living with Orthogonality

With DRY, you’re looking to minimize duplication within a system, whereas with orthogonality you reduce the interdependency among the system’s components.Systems developed with DRY in mind are more flexible, more understandable, easier to read, test and maintain.

### Topic 11 - Reversibility

Engineers prefer simple, singular solutions to problems. Singular, easy answers fit nicely on spreadsheets and project plans.

Nothing is forever - and if you rely heavily on some fact, you can almost guarantee that it will change. There is always more than one way to implement something. But critical decisions aren’t easily reversible.

Requirements, users, and hardware change faster than we can get the software developed.

When you abstract the idea of a database out - to the point where it simply provides persistence as a service - then you have the flexibility to change horses in midstream.

There are no final decisions.

#### Flexible Architecture

Maintain flexibility in the areas of architecture, deployment, and vendor integration.

Hide third-party APIs behind your own abstraction layers. Break your code into components.

Forgo following fads.

Challenges:

- Time for a little quantum mechanics with Schrodinger’s cat
  - Only when you open the box do you know which universe you are in
  - Every decision results in a different version of the future

### Topic 12 - Tracer bullets

It’s interesting to consider how to hit a target in a complex and shifting world. You face a large number of unknowns. The environment you’re working in will change before you’re done.

#### Code That Glows In The Dark

Look for something that gets us from a requirement to some aspect of the final system quickly, visibly and repeatedly. Look for the important requirements, the ones that define the system. Prioritize your development.

Use tracer bullets to find the target.

The very first tracer bullet is simply create the project, add a “hello world” and make sure it compiles and runs. Then we look for areas of uncertainty in the overall app and add the skeleton needed to make it work.

Gradually flesh out the basic structure, adding new functionality by augmenting each component of the tracer code in parallel.

Tracer code is NOT disposable: you write it for keeps. It contains all the error checking, structuring, documentation and self-checking that any production code has.

Tracer dev is consistent with the idea that a project is never finished. There will always be changes required and functions to add. It is an incremental approach.

Code is divided into modules. Modules are combined into subassemblies. Until one day, you have a complete app.

Tracer code advantages:

- Users get to see something working early
  - They won’t be disappointed by a lack of functionality; they’ll be ecstatic to see some visible progress toward their system
  - As contribution increases, so does their buy-in
  - These users will be the ones to tell you how close to the target you are
- Developers build a structure to work in
- You have an integration platform
  - You’ll be integrating every day
- You have something to demo
- You have a better feel for progress

#### Tracer Bullets Don’t Always Hit Their Target

You shouldn’t be surprised if your first couple of attempts miss. Bring it nearer the target, and be thankful that you’ve used a lean development methodology: a small body of code has low inertia - it is easy and quick to change.

#### Tracer Code VS Prototyping

With a prototype, you’re aiming to explore specific aspects of the final system. With a true prototype,you will throw away whatever you lashed together when trying out the concept and recode it properly using the lessons you’ve learned.

Tracer code shows you how the app as a whole hangs together, how the interactions will work in practice and the architectural skeleton to hang your code on.

Once you have all the components in the app plumbed together, you have a framework to show your users and your developers.

Tracer code is lean but complete, and forms part of the skeleton of the final system.

### Topic 13 - Prototypes and post-it notes

Post-it notes are great for prototyping dynamic things such as workflow and app logic, i.e. whiteboard or with an interface builder. Prototyping is a learning experience.

#### How To Use Prototypes

What details can be ignored:

- Correctness: use dummy data
- Completeness: function only in a very limited sense
- Robustness: error checking is likely to be incomplete or missing
- Style: comments or docs

Prototypes focus on specific aspects of the system being considered.
#### Prototyping Architecture

Prototypes model the entire system under consideration. As opposed to tracer bullets, none of the individual modules in the prototype system need to be particularly functional.

Some specific areas you may want to look for in the architectural prototype:

- Are the responsibilities of the major areas well defined and appropriate?
- Are the collaborations between major components well defined?
- Is coupling minimized?
- Can you ID potential sources of duplication?
- Are interface definitions and constraints acceptable?
- Does every module have an access path to the data it needs during execution? Does it have that access when it needs it?

Prototypes can save you huge amounts of time, money and pain by identifying and correcting potential problem spots early in the dev cycle.

### Topic 14 - Domain languages

Computer languages influence how you think about a problem, and how you think about communicating. We intuit intent and convert it to code.

#### Trade-offs Between Internal and External Languages

An internal language can take advantage of the features of its host language: the domain language you create is more powerful and that power comes for free.

The downside of internal domain languages is that you’re bound by the syntax and semantics of that language. Syntax is syntax. External languages have no such restrictions.

When trying to decide between internal and external languages, don’t spend more effort than you save.

### Topic 15 - Estimating

Learning to estimate to have an intuitive feel for the magnitudes of things, you will be able to show an apparent magical ability to determine their feasibility.

Estimate to avoid surprises!

#### How Accurate is Accurate Enough?

Ask about the context in which your answer will be taken. Do they need high accuracy or are they looking for a ballpark figure?

The units you use make a difference in the interpretation of the result.

#### Where Do Estimates Come From?

A basic estimating trick that always gives good answers: ask someone who’s already done it.

Understand what’s being asked and have a grasp of the scope of the domain to perform an accurate estimate.

The process of building a model leads to discoveries of underlying patterns and processes that were not apparent on the surface. Building the model introduces inaccuracies into the estimating process. Doubling the effort on the model may give you only a slight increase in accuracy.

Once you have a model, you can decompose it into components. Each component will typically have parameters.

Give each parameter a value. The trick is to work out which parameters have the most impact on the result. Basing an estimate on other sub-estimates is something common. This is where your largest errors will creep in. Calculate the answers.

Keep track of your estimating prowess. Record your estimates so you can see how close you were. Keep track of sub-estimates if used.

Practice incremental development:

- Check requirements
- Analyze risk (prioritize riskiest items earlier)
- Design, implement, integrate
- Validate with users and stakeholders

“How do you eat an elephant? One bite at a time.” - old joke

Iterate the schedule with the code.

#### What to Say When Asked for an Estimate

“I’ll get back to you”.
## Chapter 3 - The Basic Tools

A basic set of good-quality tools is a great start to a journey. The tools become conduits from the maker’s brain to the finished product - they have become extensions of their hands.

Tools amplify your talents. Let need drive your acquisitions though. Keep the basic tool set sharp and ready to use.

You can’t be a  great programmer until you become highly skilled at debugging.

### Topic 16 - The power of plain text

We gather requirements as knowledge, and then express that knowledge in our designs, implementations, tests, and documents.

Keep knowledge in plain text.

The power of text:

- Insurance against obsolescence
- Leverage existing tools
- Easier testing

The Unix philosophy: design around small, sharp tools, each intended to do one thing well.

### Topic 17 - Shell games

Use the command line interface. If you do all your work on GUIs, you are missing out on the full capabilities of your environment.

Use the power of command shells.

Gain familiarity with the shell, and you’ll find your productivity soaring. Invest some energy in becoming familiar with your shell and things will soon start falling into place.
#### A Shell of Your Own

Customize your shell by:

- Setting color themes
- Configuring a prompt
- Aliases and shell functions
- Command completion

### Topic 18 - Power Editing

Manipulate text as effortlessly as possible, because text is the basic raw material of programming. Work toward fluency in each.

Achieve editor fluency.

By becoming fluent, you no longer have to think about the mechanics of editing. Your thoughts will flow, and your programming will benefit.

Learn the commands that make your life easier.

Dig into your editor’s extension language.

If you can’t find it, build it!

### Topic 19 - Version Control

Version control system (VCS) it’s a giant undo key - a project-wide time machine. It is a repo of changes, a central meeting place for your team and your code.

Always use version control.

Make sure that everything is under version control.

#### Branching Out

New features are isolated in islands of development called branches.

How long would it take to get that machine back to the same state it was in?

- All user preferences and dotfiles
- The editor config
- The list of software installed using Homebrew
- The Ansible script used to configure apps
- All current projects

Many teams have their VCS configured so that a push to a particular branch will automatically build the system, run the tests, and if successful deploy the new code into production.

### Topic 20 - Debugging

Computer systems are still limited to doing what you tell them to do, not necessarily what you want them to do. No one writes perfect software.

#### Psychology of Debugging

Attack it as a puzzle to be solved. Concentrate on fixing the problem, not the blame.

Turn off many of the defenses you use each day to protect your ego. Don’t panic.

Beware of myopia when debugging. Resist the urge to fix just the symptoms you see. Discover the root cause of a problem.

#### Where To Start?

Gather all the relevant data.

Be accurate in your observations.

There are 2 points to the story:

- Interview the user who reported the bug
- Artificial tests
  - Brutally test both boundary conditions and realistic end-user usage patterns
- Do this systematically

#### Debugging Strategies

The best way to start fixing a bug is to make it reproducible. We want a bug that can be reproduced with a single command.

The act of writing the test informs the solution.

Read the damn error message.

Use your failing tests to trigger the problem. Know how to move up and down the call stack and examine the local stack environment.

Sensitivity to input values is another way to start with the data. Get a copy of the dataset and feed it through a locally running copy of the app.

#### The Binary Chop

It’s faster to use a divide and conquer approach.

#### Logging/Tracing

Tracing statements are those little diagnostic messages you print to the screen or to a file.

#### Rubber Ducking

Explain it to someone else.

Verbalize some of the assumptions, you may gain new insight into the problem.

#### Problem of Elimination

It is generally more profitable to assume that the app code is incorrectly calling into a library than to assume that the library itself is broken. A fault that is likely to be our own.

If you “changed only one thing”, it is likely to be responsible, directly or indirectly, no matter how far-fetched it seems. Retest the system under these new conditions.

#### The Element of Surprise

Don’t assume it - prove it.

Prove it in this context, with this data, with these boundary conditions. You need to determine why this failure wasn’t caught earlier. Consider amending the unit tests so that they would have caught it.

### Topic 22 - Engineering daybooks

Engineering daybook, a kind of journal in which they recorded what they did, things they’d learned, sketches of ideas, readings from meters. Write the date range on the spine, and stick it on the shelf next to previous daybooks.

Daybooks have 3 main benefits:

- More reliable than memory
- Place to store ideas
- Acts as a rubber duck
  - Great change to reflect

There is something special about the act of writing compared to typing.

## Chapter 4 - Pragmatic Paranoia

Perfect software doesn’t exist.

We validate all info we’re given. We check for consistency. Sometimes we don’t trust ourselves. We build defenses against our own mistakes.

The first defensive measure: Design by Contract: clients and suppliers must agree on rights and responsibilities.

We want to ensure that we do no damage while we’re working the bugs out.

Assertive programming describes an easy method of checking along the way - write code that actively verifies your assumptions.

Always stick to small steps. Let’s play it safe.

### Topic 23 - Design by Contract

Agreement concerning repercussions if either party fails to abide by the contract.
#### DBC

DBC focuses on documenting (and agreeing to) the rights and responsibilities of software modules to ensure program correctness.

What is a correct program? One that does no more and no less than it claims to do. Documenting and verifying that claim is the heart of DBC.

Expectations and claims of DBC:

- Preconditions: routine’s requirements
  - It is the caller’s responsibility to pass good data
- Post-conditions: routine is guaranteed to do
  - It will conclude
- Class invariants: class ensures condition is always true from the perspective of a caller

Contract reads as: if all the routine’s preconditions are met by the caller, the routine shall guarantee that all post-conditions and invariants will be true when it completes.

Make no mistake that failure to live up to the contract is a bug.

Lazy code: be strict in what you will accept before you begin, and promise as little as possible in return.

#### Implementing DBC

Assertions are runtime checks of logical conditions.

#### DBC and Crashing Early

Crash early and report more accurate info about the problem. 

#### Semantic Invariants

Use semantic invariants to express inviolate requirements, a kind of “philosophical contract”.

Be sure not to confuse requirements that are fixed, inviolate laws with those that are merely policies that might change with a new management regime.

That’s why we use the term semantic invariants - it must be central to the very meaning of a thing, and not subject to the whims of policy.

Try to state it clearly and unambiguously. It is our contract with all users of the system, our guarantee of behavior.

#### Dynamic Contracts and Agents

By the definition of “autonomous”, agents are free to reject requests that they do not want to honor. Any system that relies on agent technology has a critical dependence on contractual arrangements.

With enough components and agents that can negotiate their own contracts among themselves to achieve a goal, we might just solve the software productivity crisis by letting software solve it for us.

### Topic 24 - Dead programs tell no lies

We want to know when the “impossible” has happened. It’s easy to fall into the “it can’t happen” mentality. We’re coding defensively. All errors give you info. If there is an error, something very, very bad has happened.

Crash early. Crash often. The best thing you can do.

A supervisor is responsible for running code and knows what to do in case the code fails. What happens when the supervisor itself fails? Its own supervisor manages that event, leading to a design composed of supervisor trees.

When your code fails, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it as soon as possible.

A dead program normally does a lot less damage than a crippled one.

### Topic 25 - Assertive Programming

Use assertions to prevent the impossible.

“But of course that could never happen”, add code to check it. These are assertions. These checks can be invaluable.

Assertions are useful checks on an algorithm’s operation. Don’t use assertions in place of real error handling though. Assertions check for things that SHOULD NEVER happen.

Heisenbug - debugging that changes the behavior of the system being debugged.

#### Leave Assertions Turned On

You are unlikely to test even a minuscule percentage of the permutations your code will be put through. Your program runs in a dangerous world.

Your first line of defense is checking for any possible error, and your second is using assertions to try to detect those you’ve missed.

### Topic 26 - How to balance resources

We all manage resources whenever we code, all kinds of things with limited availability. Resource usage follows a predictable pattern: you allocate the resource, use it, and then deallocate it.

Finish what you start.

The function or object that allocates a resource should be responsible for deallocating it.

You can scope the lifetime of a resource to an enclosed block of some sort. It always pays to reduce scope.

Act locally.

#### Nest Allocations

Resource allocation can be extended for routines that need more than one resource at a time.

When allocating the same set of resources in different places in your code, always allocate them in the same order. This will reduce the possibility of deadlock.

For anything that you create that takes up a finite resource, consider how to balance it.

#### Checking the Balance

It is always a good idea to build coe that actually checks that resources are indeed freed appropriately. Producing wrappers for each type of resource, and using these wrappers to keep track of all allocations and deallocations is smart to do in apps.

### Topic 27 - Don’t Outrun Your Headlights

We can’t see too far ahead into the future, and the further off-axis you look, the darker it gets.

Take small steps - always.

Always take small, deliberate steps, checking for feedback and adjusting before proceeding.

Instead of wasting effort designing for an uncertain future, you can always fall back on designing your code to be replaceable. Making code replaceable will also help with cohesion, decoupling, and DRY, leading to better design overall.

#### Black Swans

Our own cognitive biases tend to blind us to changes creeping up on the edges of our work.

Avoid fortune-telling.

Much of the time, tomorrow looks a lot like today. But don’t count on it.

## Chapter 5 - Bend, or Break

Write code that’s as loose - as flexible - as possible. Otherwise we may find our code quickly becoming outdated. Make reversible decisions, so your code can stay flexible and adaptable in the face of an uncertain world. Write code that bends and doesn’t break.

### Topic 28 - Decoupling

To be flexible, individual components should be coupled to as few other components as possible.

Decoupled code is easier to change.

Avoid the following coupling disasters:

- Train wrecks - chains of method calls
  - Tell, Don’t Ask
  - In every app there are certain top-level concepts that are universal, so we have no prob creating APIs that expose public objects
  - The Law of Demeter - written by Ian Holland in 1980s to keep their company’s code functions cleaner and decoupled
  - Don’t Chain Method Calls - try not to have more than one `.` when you access something
  - Chains and pipelines - compose functions into pipelines, pipelines transform data, passing it from one function to the next
    - Introduce some coupling, but less of a barrier to changing the code than the form introduced by train wrecks
- Globalization - the dangers of static things
  - The evils of globalization - globally accessed data is an insidious source of coupling between app components
  - If your code uses global data, then it becomes difficult to split it out from the rest
  - Avoid global data
  - Exceptions include for global data with bits of intelligence behind it, wrapped logic
- Inheritance - why subclassing is dangerous

Coupling can occur just about any time two pieces of code share something. Keep a lookout for some symptoms of coupling:

- Wacky dependencies between unrelated modules or libraries
- “Simple” changes that propagate through unrelated modules in the system or break stuff elsewhere
- Devs who are afraid to change code bc they aren’t sure what might be affected
- Meetings where everyone has to attend bc no one is sure who will be affected by a change

In every app, there are certain top-level concepts that are universal. So we have no problem creating APIs that expose some universal objects.

#### The Law of Demeter (LoD)

Created by Ian Holland that states to keep their functions cleaner and decoupled.

Don't chain method calls. Try not to have more than one "." when you access something.

#### Chain and Pipelines

Pipelines transform data, passing it from one function to the next, so they introduce some coupling. However, this coupling is far less a barrier to changing the code than the form introduced by train wrecks.

#### The Evils of Globalization

Globally accessible data is an insidious source of coupling between app components. If your code uses global data, then it becomes difficult to split it out from the rest.

Avoid global data. Global data includes singletons. Global data includes external resources. If it's important enough to be global, wrap it in an API.

### Topic 29 - Juggling the Real World

Computers have to integrate into our world, not the other way around.

#### Events

An event represents the availability of information. It might come from the outside world, it might be internal, it can even be something as trivial as fetching the next element in a list.

If we write apps that respond to events, and adjust what they do based on those events, those apps will work better in the real world. Their users will find them to be more interactive.

Let's look at 4 strategies that help:

1. Finite State Machines (FSM)
2. The Observer Pattern
3. Publish/Subscribe
4. Reactive Programming and Streams

#### Finite State Machines

A state machine is basically just a specification of how to handle events. It consists of a set of states, one of which is the current state. For each state, we list the events that are significant to that state. For each of those events, we define the new current state of the system.

A pure FSM is an event stream parser. Its only output is the final state. We can beef it up by adding actions that are triggered on certain transitions.

#### The Observer Pattern

The observer pattern has a source of events, called the observable and a list of clients, the observers, who are interested in those events.

An observer registers its interest with the observable, typically by passing a reference to a function to be called. Subsequently, when the event occurs, the observable iterates down its list of observers and calls the function that each passed it. The event is given as a parameter to that call.

It is particularly prevalent in UI systems, where the callbacks are used to inform the app that some interaction has occurred. Because each of the observer has to register with the observable, it introduces coupling.

The callbacks are handled inline by the observable, synchronously, it can introduce performance bottlenecks.

#### Publish/Subscribe

Publish/Subscribe (pubsub) generalizes the observer pattern, at the same time solving the problems of coupling and performance.

In the pubsub model, we have publishes and subscribers. These are connected via channels. The channels are implemented in a separate body of code.

Every channel has a name. Subscribers register interest in one or more of these named channels, and publishers write events to them. Communication between publisher and subscriber is handled outside your code, and is potentially asynchronous.

Most cloud service providers have pubsub offerings, allowing you to connect apps around the world. Every popular language will have at least one pubsub library.

Pubsub is a good technology for decoupling the handling of asynchronous events. The downside is that it can be hard to see what is going on in a system that uses pubsub heavily.

Pubsub is still basically just a message passing system.

#### Reactive Programming, Streams and Events

It's clear that events can also be used to trigger reactions in code, but it isn't necessarily easy to plumb them in. That's where streams come in.

Streams let us treat events as if they were a collection of data. We can treat streams just like any other collection: we can manipulate, combine, filter, and do all theh other data-ish things we know so well. Streams can be asynchronous.

Event streams are normally populated as events occur, which implies that the observables that populate them can run in parallel.

#### Streams of Events are Asynchronous Collections

Event streams unify synchronous and asynchronous processing behind a common, convenient API.

#### Events are Ubiquitous

Code that's crafted around events can be more responsive and better decoupled than its more linear counterpart.

### Topic 30 - Transforming Programming

All programs transform data, converting an input into an output.

We need to get back to thinking of programs as being something that transforms inputs into outputs.

#### Finding Transformations

Programming is about code, but programs are about data. The easiest way to find the transformations is to start with the requirement and determine its inputs and outputs.

You can then find steps that lead you from input to output. This is a top-down approach.

Using a pipeline means that you're automatically thinking in terms of transforming data; each time you see a pipeline you're actually seeing a place where data is flowing between one transformation and the next.

Don't hoard state; pass it around.

Instead of little pools of data spread all over the system, think of data as a mighty river, a flow. It is free to represent the unfolding progress of our app as it transforms its inputs into its outputs.

#### What About Error Handling?

We never pass raw values between transformations. Instead, we wrap them in a data structure (or type) which also tells us if the contained value is valid. You can handle checking for errors inside your transformations or outside them.

When an error occurs, we don't want to run code further down a pipeline, and we don't want that code to know that this is happening.

#### Transformations Transform Programming

Once you've developed the habit you'll find your code becomes cleaner, your functions shorter, and your designs flatter.

### Topic 31 - Inheritance Tax

Inheritance was a way of combining types, where inheritance was a dynamic organization of behaviors.

Those who don't like typing save their fingers by using inheritance to add common functionality from a base class into child classes. 

Those who like types use inheritance to express the relationships between classes. 

Both kinds of inheritance have problems.

#### Problems Using Inheritance to Share Code

Inheritance is coupling.

Some folks view inheritance as a way of defining new types. They view problems the way Victorian gentleman scientists viewed nature, as something to be broken down into categories.

Don't pay inheritance tax! The alternatives are better. 3 suggested techniques to help you stop using inheritance:

- Interfaces and protocols
- Delegation
- Mixins and traits

#### Interfaces and Protocols

Most OO languages allow you to specify that a class implements one or more sets of behavior. Some languages call them interfaces, other languages call them protocols, and some call them traits.

What makes interfaces and protocols so powerful is that we can use them as types, and any class that implements the appropriate interface will be compatible with that type.

Prefer interfaces to express polymorphism. Interfaces and protocols give us polymorphism without inheritance.

#### Delegation

Delegate to services: has A trumps is A

#### Mixins, Traits, Categories, Protocol Extensions...

The basic idea is simple: we want to be able to extend classes and objects with new functionality without using inheritance.

The important thing is the capability that all these implementations have: merging functionality between existing things and new things.

We all know our business objects need validation code to prevent bad data from infiltrating our calculations. Use mixins to share functionality.

### Topic 32 - Configuration

When code relies on values that may change after the app has gone live, keep those values external to the app. Parameterizing your app helps your code adapt to the place where it runs.

The config is read into your app as a data structure, normally when the app starts. Commonly, this data structure is made global. However, it is preferable to not do that. Instead, wrap the config info behind a thin API.

#### Configuration As A Service

Rather than in a flat file or database, we'd like to see it stored behind a service API.

The idea we should have to stop and restart an app to change a single parameter is hopelessly out of touch with modern realities. Configuration data drives the runtime behavior of an app. When config values change, there's no need to rebuild the code.

## Chapter 6 - Concurrency

Concurrency is when the execution of 2 or more pieces of code act as if they run at the same time. Parallelism is when they do run at the same time.

Concurrency is a requirement if you want your app to be able to deal with the real world, where things are asynchronous.

Temporal coupling happens when your code imposes a sequence on things that is not required to solve the problem at hand.

Our languages have feats that are relatively safe when used sequentially but become a liability once two things can happen at the same time. One of the biggest culprits is shared state.

Shared state is incorrect state.

Actor model, where independent processes, which share no data, communicate over channels using defined, simple semantics.

### Topic 33 - Breaking Temporal Coupling

There are 2 aspects of time that are important to us: concurrency (things happening at the same time) and ordering (the relative positions of things in time).

#### Looking for Concurrency

Analyze workflow to improve concurrency. You can use activity diagrams to maximize parallelism by identifying activities that could be performed in parallel, but aren't.

#### Opportunities for Concurrency

What we're looking for when we're designing concurrency is to find activities that take time, but not time in our code.

#### Opportunities for Parallelism

Concurrency is a software mechanism, and parallelism is a hardware concern.

### Topic 34 - Shared State is Incorrect State

The problem with shared state is that it cannot guarantee that its view of that memory is consistent.

#### Semaphores and Other Forms of Mutual Exclusion

Semaphore is simply a thing that only one person can own at a time.

#### Non-transactional Update

Problems can pop up anywhere where your app code shares mutable resources.

Random failures are often concurrency issues.

Most languages have library support for some kind of exclusive access to shared resources. They may call it mutexes (for mutual exclusion), monitors, or semaphores.

### Topic 35 - Actors and Processes

Actors and processes offer interesting ways of implementing concurrency without the burden of synchronizing access to shared memory.

An actor is an independent virtual processor with its own local (and private) state. Each actor has a mailbox. When processing a message, an actor can create other actors, send messages to other actors that it knows about, and create a new state that will become the current state when the next message is processed.

A process is typically a more general-purpose virtual processor, often implemented by the OS to faciliate concurrency.

#### Actors Can Only Be Concurrent

A few true statements about actors:

- There's no single thing that's in control
- The only state in the system is held in messages and in local state of each actor
  - Messages cannot be examined except by being read by their recipient, and local state is inaccessible outside the actor
- All messages are one way
  - There's no concept of replying
- An actor processes each message to completion, and only processes one message at a time

Actors execute concurrently, asynchronously and share nothing.

Use actors for concurrency without shared state.

#### A SimpleActor

Keys are the message types that it receives and the values are functions to run when that particular message is received.

#### No Explicit Concurrency

In the actor model, there's no need to write any code to handle concurrency, as there is no shared state.

### Topic 36 - Blackboards

A blackboard, in combo with a rules engine that encapsulates the legal reqs, is an elegant solution to the difficulties found here. Order of data arrival is irrelevant: when a fact is posted it can trigger the appropriate rules. Feedback is easily handled as well: the output of any set of rules can post to the blackboard and cause the triggering of yet more applicable rules.

Use blackboards to coordinate workflow.

#### Messaging Systems Can Be Like Blackboards

Many apps are constructed using small, decoupled services, all communicating via some form of messaging system.

They offer persistence (in the form of an event log) and the ability to retrieve messages through a form of pattern matching.

#### But It's Not That Simple

The actor and/or blackboard and/or microservice approach to architecture removes a whole class of potential concurrency problems for your apps. These approaches are harder to reason about, bc a lot of the action is indirect.

You'll also need a good tooling to be able to trace messages and facts as they progress through the system. A useful technique is to add a unique trace ID when a function is initiated and then propagate it to all the actors involved. You'll be able to reconstruct what happens from the log files.

These kinds of systems can be more troublesome to deploy and manage, as there are more moving parts.

## Chapter 7 - While You Are Coding

You can better harness your instincts and non-conscious thoughts when you listen to your Lizard Brain.

Pragmatic programmers think critically about all code. We constantly see room for improvement in our programs and our designs.

The major benefits of testing happen when you think about and write the tests, not just when you run them.

It's critical that you write code that is readable and easy to reason about.

### Topic 37 - Listen To Your Lizard Brain

As you gain exp as a programmer, your brain is laying down layers of tacit knowledge. Instincts share one thing: they have no words. Instincts make you feel, not think.

#### Fear Of The Blank Page

Many of us would prefer to put off making the initial commitment of starting. Give it time and your doubts will probably crystallize into something more solid, something you can address. Let you rinstincts contribute to your performance.

We can take errors in that code as reflections on our competence, perhaps there's an element of imposter syndrome. Fight it!

Your code is trying to tell you something. it's saying that this is harder than it should be. Maybe the structure or design is wrong, maybe you're solving the wrong problem, or maybe you're just creating an ant farm's worth of bugs. Whatever the reason, your lizard brain is sensing feedback from the code, do not ignore it.

#### How To Talk Lizard

Give yourself a little time and space to let your brain organize itself. If that's not working, try externalizing the issue. Expose different parts of your brain to the issue. We need to tell your brain that what you're about to do doesn't matter. And we do that by prototyping.

A brain hack is to tell yourself you need to prototype something. Do the following:

1. Write "I'm prototyping" on a sticky note, and stick it on the side of your screen
2. Remind yourself that prototypes are meant to fail
   - Remind yourself that prototypes are meant to be thrown away, even if they don't fail
3. In your empty editor buffer, create a comment describing in one sentence what you want to do or learn
4. Start coding

### Topic 38 - Programming By Coincidence

We should avoid programming by coincidence - relying on luck and accidental successes - in favor of programming deliberately.

For code you write that others will call, the basic principles of good modularization and of hiding implementation behind small, well-documented interfaces can all help.

For routines you call, rely only on documented behavior.

#### Phantom Patterns

Human beings are designed to see patterns and causes, even when it's just a coincidence. Don't assume it, prove it.

#### Implicit Assumptions

Coincidences can mislead at all levels. Assumptions are rarely documented and are often in conflict between diff developers. Assumptions that aren't based on well-established facts are the bane of all projects.

#### How To Program Deliberately

- Always be aware of what you are doing
- Can you explain the code in detail
- If you're not sure why it works, you won't know why it fails
- Proceed from a plan
- Rely only on reliable things, don't depend on assumptions, and assume the worst
- Document your assumptions
- Don't just test your code, but test your assumptions as well
  - Don't guess, actually try it
- Spend time on the important aspects, prioritize your effort
- Don't let existing code dictate future code, all code can be replaced

### Topic 39 - Algorithm Speed

Estimating the resources that algorithms use - time, processor, memory and so on.

Writing approximations call the Big-O notation.

The size of the input will affect the algorithm: the larger the input, the longer the running time or the more memory used.

#### Big-O Notation

The Big-O notation, written O(), is a mathematical way of dealing with approximations. Think of the O as meaning on the "order of".

The O() notation puts an upper bound on the value of the thing we're measuring (time, memory and so on). The highest-order term will dominate the value as "n" increases, the convetion is to remove all low-order terms, and not to bother sowing any constant multiplying factors.

Big-O is never going to give you actual numbers for time or memory or whatever: it simply tells you how these values will change as the input changes.

The O() notation doesn't apply just to time; you can use it to represent any other resources used by an algo.

#### Common Sense Estimation

List of basic algos:

- Simple Loops: algo is likely to be O(n), time increases linearly with "n"
  - Examples include exhaustive searches, finding the max value in an array, generating check-sums, etc.
- Nested Loops: algo becomes O(m x n), where m and n are the 2 loops' limits
  - Used in "bubble sort", where the outer loop scans each element in the array in turn, and the inner loop works out where to place that element in the sorted result
  - Such sorting algos tend to be O(n^2)
- Binary chop: algo halves the set of things it considers each time around the loop, O(lg n)
  - Examples are sorted list, traversing a binary tree, finding the first set bit in a machine word, etc
- Divide and conquer: partition their input work on the two halves independently, and then combine the result can be O(n lg n)
  - Classic example is quicksort, which partitions the data into 2 halves and recursively sorting each
  - O(n^2), bc its behavior degrades when it is fed sorted input, the avg. runtime of quicksort is O(n lg n)
- Combinatoric: start looking at the permutations of things
  - Examples include algos for many of the acknowledged hard problems - the traveling salesman problem, optimally packing things into a container, partitioning a set of numbers so that each set has the same total, etc.

#### Algorithms Speed In Practice

Whenever you find yourself writing a simple loop, then you're looking at O(n) algo. If that loop contains an inner loop (nested loop), then you're looking at O(m x n).

Estimate the order of your algos. If you have an algo that is O(n^2), try to find a divide-and-conquer approach that will take you down to O(n lg n).

Test your estimates. Use code profilers to count the number of times the diff steps in your algo get executed, and plot these figures against the size of the input.

Be wary of premature optimization. It's always a good idea to make sure an algo really is a bottleneck before investing time to improve it.

Challenges:

- Every dev should have a feel for how algos are designed and analyzed

### Topic 40 - Refactoring

Software is more like gardening - it is more organic than concrete. You plant many things in a garden according to an initial plan and conditions. Some thrive, others are destined to end up as compost.

Things that don't work out as planned need to be weeded or pruned.

Rewriting, reworking and re-architecting code is collectively known as restructuring, AKA refactoring.

Martin Fowler states refactoring is "disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior".

Refactoring is a day-to-day activity. It's a targeted, precision approach to help keep the code easy to change.

To guarantee that the external behavior hasn't changed, you need good, automated unit testing that validates the behavior of the code.

#### When Should You Refactor?

You refactor when you've learned something; when you understand something better than you did last year, yesterday, or even just ten minutes ago.

There's no time like the present. What qualifies code to be refactored:

- Duplication: violation of the DRY principle
- Nonorthogonal design
- Outdated knowledge
- Usage: must have features perhaps weren't
- Performance: improvements
- The Test Pass

Fail to refactor now, and there'll be a far greater time investment to fix the problem down the road. Refactor early, refactor often.

You shouldn't need a week to refactor a piece of code - that's a full-on rewrite.

Refactoring is redesigning. Refactoring is an activity that needs to be undertaken slowly, deliberately and carefully:

1. Don't try to refactor and add functionality at the same time
2. Make sure you have good tests before you begin refactoring
3. Take short, deliberate steps
   - Refactoring often involves making many localized changes that result in a larger-scale change

### Topic 41 - Test To Code

